// Copyright Â© 2018 J. Strobus White.
// This file is part of the blocktop blockchain development kit.
//
// Blocktop is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Blocktop is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with blocktop. If not, see <http://www.gnu.org/licenses/>.

package consensus

import (
	"context"
	"errors"
	"math/rand"
	"sync"
	"time"

	spec "github.com/blocktop/go-spec"
	"github.com/spf13/viper"
)

// Consensus tracks incoming blocks that are younger than Depth. It tracks
// all the branches of blocks and prunes according to rules defined in the
// CompareBlocks function. Client programs can retrieve the most favorable head
// for its next block computation using the GetBestBranch method.
type Consensus struct {
	sync.Mutex

	// The spec used to determine which blocks are in play
	CompareBlocks spec.BlockComparator

	// Currently active blocks in the consensus finder
	blocks map[string]spec.Block

	// Current known heads in the consensus finder
	heads []string

	// Blocks generated by this node
	localBlocks []string

	// spec.Blocks already submitted for a given parent block
	alreadySeen map[string][]string

	// Max lock number that the local node has already maxCompeted for
	maxCompeted int64

	// Blocks disqualified from consideration
	disqualified []spec.Block

	// Chan to send to when block is confirmed (removed as an old block)
	confirm chan spec.Block
	confirmLocal chan spec.Block

	compete chan []spec.Block

	evaluate chan spec.Block

	headTimer *time.Timer

	bestHead spec.Block
}

var consensus *Consensus

// NewConsensus constructs a new Consensus instance with the specified Depth
// and blockComparator function. If Depth is 0 then DefaultDepth is
// used. If blockComparator is nil then DefaultBlockComparator is used.
func New(consensusDepth uint, blockComparator spec.BlockComparator) *Consensus {
	if consensus != nil {
		panic("Consensus object already created")
	}

	if blockComparator == nil {
		panic(errors.New("blockComparator must be provided"))
	}

	c := &Consensus{CompareBlocks: blockComparator}

	c.blocks = make(map[string]spec.Block)
	c.heads = make([]string, 0)
	c.alreadySeen = make(map[string][]string)
	c.maxCompeted = int64(-1)
	c.evaluate = make(chan spec.Block, 25)
	c.confirm = make(chan spec.Block, 25)
	c.confirmLocal = make(chan spec.Block, 25)
	c.compete = make(chan []spec.Block, 1)

	consensus = c
	return c
}

func (c *Consensus) Start(ctx context.Context) {
	go c.evaluateHeads(ctx)
	tree.start(ctx)
}

// WasSeen returns true if the given block has already been sent to the
// AddBlock method.
func (c *Consensus) WasSeen(block spec.Block) bool {
	c.Lock()
	seen := c.alreadySeen[block.GetParentID()]
	c.Unlock()

	if seen == nil {
		return false
	}

	blockID := block.GetID()

	for _, id := range seen {
		if id == blockID {
			return true
		}
	}
	return false
}

// SetCompeted is called by the client program to tell the Consensus instance
// that the client program has already generated a block for the given head.
// This block will no longer be returned as a head by GetBestBranch.
func (c *Consensus) SetCompeted(head spec.Block) {
	if c.blocks[head.GetID()] == nil {
		return
	}
	if int64(head.GetBlockNumber()) > c.maxCompeted {
		c.maxCompeted = int64(head.GetBlockNumber())
	}
}

func (c *Consensus) GetConfirmChan() <-chan spec.Block {
	return c.confirm
}

func (c *Consensus) GetConfirmLocalChan() <-chan spec.Block {
	return c.confirm
}

func (c *Consensus) GetCompetitionChan() <-chan []spec.Block {
	return c.compete
}

// AddBlock adds the given block to the consensus tracking. Sibling and
// children branches are pruned according to the rules in the spec.BlockComparator
// function. The function returns true if the block was added, or false
// if the new block was pruned in the process of being added.
func (c *Consensus) AddBlock(block spec.Block, isLocal bool) (added bool) {
	if c.WasSeen(block) {
		return false
	}
	c.setSeen(block)

	// make sure block is not too old
	maxDepth := viper.GetInt("blockchain.consensus.depth") - viper.GetInt("blockchain.consensus.depthBuffer")
	if c.getDepth(block) > maxDepth {
		return false
	}

	parentID := block.GetParentID()
	blockID := block.GetID()
	parent := c.blocks[parentID]

	// make sure parent was not aready eliminated
	addDisqualified := viper.GetBool("blockchain.metrics.trackall")
	if parent != nil && c.isDisqualified(parent) {
		if addDisqualified {
			metrics.AddBlock(block)
			go metrics.DisqualifyBlock(block)
		}
		return false
	}

	if parent != nil && block.GetBlockNumber() != parent.GetBlockNumber()+1 {
		return false
	}

	c.Lock()
	defer c.Unlock()

	if parent != nil {
		// remove head
		c.removeHead(parentID)
	}

	// remove unfavorable siblings
	// note: the parent does not have to be in the system, just collect blocks with same parentID
	siblings := append(c.getChildren(parentID), block)
	favorableSibling := c.disqualifyUnfavorables(siblings)
	if favorableSibling.GetID() != blockID {
		//c.disqualified = append(c.disqualified, block)
		if addDisqualified {
			metrics.AddBlock(block)
			go metrics.DisqualifyBlock(block)
		}
		return false // new block was not favorable against siblings
	}

	go metrics.AddBlock(block)

	var evaluate bool
	children := c.getChildren(blockID)
	if len(children) == 0 {
		// this will be a head block
		c.addHead(blockID)
		evaluate = true
	} else {
		// take this opportunity to keep the most favorable child
		c.disqualifyUnfavorables(children)
	}

	if isLocal {
		c.localBlocks = append(c.localBlocks, blockID)
	}

	c.blocks[blockID] = block
	c.removeOldBlocks()

	// this has to be done after adding the block to c.blocks
	if evaluate {
		c.evaluate <- block
	}

	return true
}

func (c *Consensus) evaluateHeads(ctx context.Context) {
	
	for {
		select {
		case <-ctx.Done():
			return
		case <-c.evaluate:
			c.evaluateHead()
		}
	}
}

// GetBestBranch returns the most favorable branch for the client program to
// compete for the next block. The method returns nil if there are no
// favorable branches. Otherwise it returns the best branch as an array of
// blocks with the head block as the zeroth element.
func (c *Consensus) evaluateHead() {
	if len(c.heads) == 0 {
		return
	}

	c.Lock()
	defer c.Unlock()

	hs := make([]spec.Block, 0)
	maxHead := uint64(0)
	for _, headID := range c.heads {
		head := c.blocks[headID]
		blockNumber := head.GetBlockNumber()
		if int64(blockNumber) > c.maxCompeted && (blockNumber == 0 || c.getParent(headID) != nil) {
			hs = append(hs, head)
			if blockNumber > maxHead {
				maxHead = blockNumber
			}
		}
	}

	// filters the list to contain only blocks at max block number
	for i := 0; i < len(hs); i++ {
		if hs[i].GetBlockNumber() < maxHead {
			hs = append(hs[:i], hs[i+1:]...)
		}
	}

	bestHead := c.CompareBlocks(hs)

	if bestHead == nil {
		if len(hs) > 0 {
			bestHead = hs[rand.Intn(len(hs))]
		} else {
			return
		}
	}

	newBestHead := c.bestHead == nil
	if !newBestHead && c.bestHead.GetBlockNumber() == maxHead {
		bestHead = c.CompareBlocks([]spec.Block{bestHead, c.bestHead})
		newBestHead = c.bestHead.GetID() != bestHead.GetID()
	}

	branch := c.getBranch(bestHead)

	if branch != nil && len(branch) > 0 && newBestHead {
		if c.headTimer != nil {
			c.headTimer.Stop()
			c.headTimer = nil
		}
		now := time.Now().UnixNano()
		latestTime := time.Duration(now) - viper.GetDuration("blockchain.blockInterval")
		duration := time.Duration(bestHead.GetTimestamp()) * time.Millisecond - latestTime
		if duration <= 0 {
			c.compete <- branch
		} else {
			c.headTimer = time.AfterFunc(duration, func() {
				c.compete <- branch
				c.headTimer = nil
			})
		}
	}
}

type blockForCompare struct {
	block     spec.Block
	maxNumber uint64
}

// disqualifies unfavorable blocks and returns the most favorable
func (c *Consensus) disqualifyUnfavorables(blocks []spec.Block) spec.Block {
	if len(blocks) == 0 {
		return nil
	}
	if len(blocks) == 1 {
		return blocks[0]
	}

	favorable := c.CompareBlocks(blocks)
	favorableID := favorable.GetID()
	for _, b := range blocks {
		blockID := b.GetID()
		if blockID != favorableID {
			c.removeBranch(blockID, true)
		}
	}

	return favorable
}

func (c *Consensus) getBranchMaxBlockNumber(block spec.Block) uint64 {
	maxBlockNumber := block.GetBlockNumber()
	children := c.getChildren(block.GetID())
	for _, child := range children {
		childMaxBlockNumber := c.getBranchMaxBlockNumber(child)
		if childMaxBlockNumber > maxBlockNumber {
			maxBlockNumber = childMaxBlockNumber
		}
	}

	return maxBlockNumber
}

func (c *Consensus) getBranch(block spec.Block) []spec.Block {
	this := []spec.Block{block}
	parent := c.blocks[block.GetParentID()]
	if parent == nil {
		return this
	}
	return append(this, c.getBranch(parent)...)
}

func (c *Consensus) setSeen(block spec.Block) {
	parentID := block.GetParentID()

	c.Lock()
	seen := c.alreadySeen[parentID]

	if seen == nil {
		seen = make([]string, 0)
	}

	c.alreadySeen[parentID] = append(seen, block.GetID())
	c.Unlock()
}

func (c *Consensus) addHead(blockID string) {
	if !c.isHead(blockID) {
		c.heads = append(c.heads, blockID)
	}
}

func (c *Consensus) isHead(blockID string) bool {
	for _, id := range c.heads {
		if id == blockID {
			return true
		}
	}

	return false
}

func (c *Consensus) getParent(blockID string) spec.Block {
	block := c.blocks[blockID]
	if block == nil {
		return nil
	}

	parentID := block.GetParentID()

	return c.blocks[parentID]
}

func (c *Consensus) getChildren(parentBlockID string) []spec.Block {
	children := make([]spec.Block, 0)

	for _, b := range c.blocks {
		if b.GetParentID() == parentBlockID {
			children = append(children, b)
		}
	}

	return children
}

func (c *Consensus) removeBranch(blockID string, disqualify bool) {
	children := c.getChildren(blockID)
	for _, child := range children {
		c.removeBranch(child.GetID(), disqualify)
	}

	c.removeBlock(blockID, disqualify)
}

func (c *Consensus) removeBlock(blockID string, disqualify bool) {
	block := c.blocks[blockID]
	if block == nil {
		return
	}

	for i, l := range c.localBlocks {
		if l == blockID {
			c.localBlocks = append(c.localBlocks[:i], c.localBlocks[i+1:]...)
			break
		}
	}

	c.removeHead(blockID)
	delete(c.blocks, blockID)
	delete(c.alreadySeen, blockID)
	if disqualify {
		c.disqualifyBlock(block)
	}
}

func (c *Consensus) disqualifyBlock(block spec.Block) {
	blockID := block.GetID()
	for _, e := range c.disqualified {
		if e.GetID() == blockID {
			return
		}
	}
	c.disqualified = append(c.disqualified, block)

	go metrics.DisqualifyBlock(block)

	for _, child := range c.getChildren(blockID) {
		c.disqualifyBlock(child)
	}
}

func (c *Consensus) removeHead(blockID string) {
	c.heads = deleteFromSlice(c.heads, blockID)
}

func (c *Consensus) removeOldBlocks() {
	maxBlockNumber := c.getMaxBlockNumber()

	c.disqualifyOldBlocks(maxBlockNumber)
	c.removeDisqualified(maxBlockNumber)

	consensusDepth := viper.GetInt("blockchain.consensus.depth")

	if maxBlockNumber < uint64(consensusDepth) {
		return // blockchain is two short to begin confirmation
	}

	confirmedCandidates := make([]spec.Block, 0)
	minTrackedBlockNumber := maxBlockNumber - uint64(consensusDepth)
	for _, block := range c.blocks {
		blockNumber := block.GetBlockNumber()
		if blockNumber < minTrackedBlockNumber {
			confirmedCandidates = append(confirmedCandidates, block)
		}
	}
	if len(confirmedCandidates) == 0 {
		return
	}
	if len(confirmedCandidates) == 1 {
		c.confirmBlock(confirmedCandidates[0])
		return
	}

	// run-off among candidates for confirmation
	// get min block number and filter candidates by minimum
	minBlockNumber := ^uint64(0)
	for _, conf := range confirmedCandidates {
		if conf.GetBlockNumber() < minBlockNumber {
			minBlockNumber = conf.GetBlockNumber()
		}
	}
	for i := 0; i < len(confirmedCandidates); i++ {
		conf := confirmedCandidates[i]
		if conf.GetBlockNumber() != minBlockNumber {
			confirmedCandidates = append(confirmedCandidates[:i], confirmedCandidates[i+1:]...)
		}
	}

	blockToConfirm := c.CompareBlocks(confirmedCandidates)
	if blockToConfirm == nil {
		return
	}
	c.confirmBlock(blockToConfirm) // which will also remove it without disqualifying it

	// remove the rest as diqualified
	for _, conf := range confirmedCandidates {
		if conf.GetID() != blockToConfirm.GetID() {
			c.removeBlock(conf.GetID(), true)
		}
	}
}

func (c *Consensus) removeDisqualified(maxBlockNumber uint64) {
	for i := 0; i < len(c.disqualified); i++ {
		block := c.disqualified[i]
		blockNumber := block.GetBlockNumber()
		if maxBlockNumber >= blockNumber && uint(maxBlockNumber-blockNumber) > uint(viper.GetInt("blockchain.consensus.depth")) {
			go metrics.RemoveBlock(block)
			c.disqualified = append(c.disqualified[:i], c.disqualified[i+1:]...)
		}
	}
}

func (c *Consensus) disqualifyOldBlocks(maxBlockNumber uint64) {
	depthMap := make(map[uint64][]spec.Block, 0)
	noChildren := make([]spec.Block, 0)
	maxDepth := uint64(viper.GetInt("blockchain.consensus.depth") - viper.GetInt("blockchain.consensus.depthBuffer"))
	for _, b := range c.blocks {
		if c.isDisqualified(b) {
			continue
		}
		blockNumber := b.GetBlockNumber()
		depth := maxBlockNumber - blockNumber
		if depth > maxDepth {
			if len(c.getChildren(b.GetID())) == 0 {
				noChildren = append(noChildren, b)
			}
			depthBlocks := depthMap[depth]
			if depthBlocks == nil {
				depthBlocks = make([]spec.Block, 0)
			}
			depthBlocks = append(depthBlocks, b)
			depthMap[depth] = depthBlocks
		}
	}

	for _, nc := range noChildren {
		c.removeBlock(nc.GetID(), true)
	}

	for _, blocks := range depthMap {
		c.disqualifyUnfavorables(blocks)
	}
}

func (c *Consensus) isDisqualified(block spec.Block) bool {
	blockID := block.GetID()
	for _, b := range c.disqualified {
		if b.GetID() == blockID {
			return true
		}
	}
	return false
}

func (c *Consensus) isLocal(blockID string) bool {
	for _, l := range c.localBlocks {
		if l == blockID {
			return true
		}
	}
	return false
}

func (c *Consensus) confirmBlock(block spec.Block) {
	if c.isLocal(block.GetID()) {
		c.confirmLocal <- block
	} else {
		c.confirm <- block
	}

	c.removeBlock(block.GetID(), false)
	go metrics.RemoveBlock(block)
}

func (c *Consensus) getMaxBlockNumber() uint64 {
	var max uint64
	for _, headID := range c.heads {
		blockNumber := c.blocks[headID].GetBlockNumber()
		if blockNumber > max {
			max = blockNumber
		}
	}

	return max
}

func (c *Consensus) getDepth(block spec.Block) int {
	return int(int64(c.getMaxBlockNumber()) - int64(block.GetBlockNumber()))
}

func deleteFromSlice(slice []string, value string) []string {
	for i, v := range slice {
		if v == value {
			return append(slice[:i], slice[i+1:]...)
		}
	}

	return slice
}

func getIndex(slice []string, value string) int {
	for i, v := range slice {
		if v == value {
			return i
		}
	}

	return -1
}
